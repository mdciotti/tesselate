<!DOCTYPE html>
<html>
	<head>
		<title>Tyler</title>
		<meta charset="utf-8" />
		<style>body{margin:0;background:black}canvas{display:block}</style>
	</head>
	<body>
		<canvas id="screen"></canvas>
		<script>

var Engine = function () {
	this.entities = [];
	this.init();
};

Engine.prototype.dom = {
	canvas: null,
	context: null,
	init: function () {
		this.canvas = document.getElementById('screen');
		this.context = this.canvas.getContext('2d');
		this.canvas.width = window.innerWidth;
		this.canvas.height = window.innerHeight;
		this.context.translate(this.canvas.width/2, this.canvas.height/2);
		// Don't use if need to draw pictures or text
		//this.context.scale(1, -1);
	}
};

var Map = function () {};

Map.prototype = {
	data: [],
	tileSize: [20, 20],
	scale: 3,
	terrain: new Image(),
	setData: function (rows, cols, data) {
		var size = rows * cols, rowData;
		for (var i = 0; i < rows; i++) {
			rowData = data.substr(i * cols, cols);
			this.data.push(rowData.split(''));
		}
	},
	setTerrain: function (imgURL) {
		this.terrain.src = imgURL;
	}
};

Engine.prototype.map = {
	current: new Map(),
	maps: [],
};

Engine.prototype.render = function () {
	//console.log("Engine.render()", this);
	var canvas, ctx, minX, minY, maxX, maxY;
	canvas = this.dom.canvas;
	ctx = this.dom.context;
	var map = this.map.current;
	minX = Math.floor(-canvas.width/2);
	minY = Math.floor(-canvas.height/2);
	maxX = Math.floor(canvas.width/2);
	maxY = Math.floor(canvas.height/2);
	
	// Clear
	ctx.fillStyle = "rgba(0,0,0,1)";
	ctx.fillRect(minX, minY, canvas.width, canvas.height);

	ctx.mozImageSmoothingEnabled = false;
	// Map
	var rows, cols, multX, multY, sourceX, sourceY, tile;
	multX = map.tileSize[0] * map.scale;
	multY = map.tileSize[1] * map.scale;
	rows = map.data.length;
	cols = map.data[0].length;
	
	for (r = 0; r < rows; r++) {
		for (c = 0; c < cols; c++) {
			tile = map.data[r][c];
			sourceX = map.tileSize[0] * tile[0];
			sourceY = map.tileSize[1] * tile[1];
			ctx.drawImage(map.terrain, sourceX, sourceY, map.tileSize[0], map.tileSize[1], minX + c*multX, minY + r*multY, multX, multY);
		}
	}
	console.log("done!");
};

Engine.prototype.init = function () {
	this.dom.init();
};


var Tile = {
	Void: { main: [0, 0] },
	Air: { main: [0, 0] },
	SquareTile: { main: [37,2] },
	RoundTile: { main: [37, 3] },
	Stone: {
		main: [1, 2],
		concave: {
			NW: [0, 1],
			NE: [2, 1],
			SE: [2, 3],
			SW: [0, 3]
		},
		convex: {
			NW: [3, 1],
			NE: [5, 1],
			SE: [5, 3],
			SW: [3, 3]
		},
		edge: {
			N: [4, 1],
			E: [5, 2],
			S: [4, 3],
			W: [3, 2]
		},
		ramp: {
			R: [6, 1],
			L: [7, 1]
		}
	}
};


var game = new Engine();
game.map.current.data = [
	[Tile.Stone.convex.NW, Tile.Stone.edge.N, Tile.Stone.convex.NE, Tile.Air.main, Tile.Air.main, Tile.Air.main, Tile.Air.main],
	[Tile.Stone.edge.W, Tile.Stone.main, Tile.Stone.concave.NE, Tile.Stone.convex.NE, Tile.Air.main, Tile.Air.main, Tile.Air.main],
	[Tile.Stone.edge.W, Tile.Stone.main, Tile.Stone.main, Tile.Stone.ramp.L, Tile.Stone.convex.NE, Tile.Air.main, Tile.Air.main],
	[Tile.Stone.convex.SW, Tile.Stone.concave.SW, Tile.Stone.main, Tile.Stone.main, Tile.Stone.ramp.L, Tile.Stone.edge.N, Tile.Stone.convex.NE],
	[Tile.Air.main, Tile.Stone.edge.W, Tile.Stone.main, Tile.Stone.concave.SE, Tile.Stone.main, Tile.Stone.main, Tile.Stone.edge.E],
	[Tile.Air.main, Tile.Stone.convex.SW, Tile.Stone.edge.S, Tile.Stone.convex.SE, Tile.Stone.edge.S, Tile.Stone.edge.S, Tile.Stone.convex.SE]
];
game.map.current.setTerrain("sprites/terrain.png");
// game.render();

		</script>
	</body>
</html>
